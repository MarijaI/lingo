<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>Module: Diff::LCS</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="module">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/diff/lcs/callbacks.rb
    <li>lib/diff/lcs.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-LCS">::LCS</a>
    
    <li><a href="#method-c-__diff_direction">::__diff_direction</a>
    
    <li><a href="#method-c-__inverse_vector">::__inverse_vector</a>
    
    <li><a href="#method-c-__lcs">::__lcs</a>
    
    <li><a href="#method-c-__normalize_patchset">::__normalize_patchset</a>
    
    <li><a href="#method-c-__position_hash">::__position_hash</a>
    
    <li><a href="#method-c-__replace_next_larger">::__replace_next_larger</a>
    
    <li><a href="#method-c-diff">::diff</a>
    
    <li><a href="#method-c-patch">::patch</a>
    
    <li><a href="#method-c-patch-21">::patch!</a>
    
    <li><a href="#method-c-sdiff">::sdiff</a>
    
    <li><a href="#method-c-traverse_balanced">::traverse_balanced</a>
    
    <li><a href="#method-c-traverse_sequences">::traverse_sequences</a>
    
    <li><a href="#method-c-unpatch-21">::unpatch!</a>
    
    <li><a href="#method-i-diff">#diff</a>
    
    <li><a href="#method-i-lcs">#lcs</a>
    
    <li><a href="#method-i-patch">#patch</a>
    
    <li><a href="#method-i-patch-21">#patch!</a>
    
    <li><a href="#method-i-sdiff">#sdiff</a>
    
    <li><a href="#method-i-traverse_balanced">#traverse_balanced</a>
    
    <li><a href="#method-i-traverse_sequences">#traverse_sequences</a>
    
    <li><a href="#method-i-unpatch">#unpatch</a>
    
    <li><a href="#method-i-unpatch-21">#unpatch!</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../COPYING.html">COPYING</a>
  
    <li class="file"><a href="../ChangeLog.html">ChangeLog</a>
  
    <li class="file"><a href="../README.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Attendee.html">Attendee</a>
  
    <li><a href="../Attendee/Abbreviator.html">Attendee::Abbreviator</a>
  
    <li><a href="../Attendee/Debugger.html">Attendee::Debugger</a>
  
    <li><a href="../Attendee/Decomposer.html">Attendee::Decomposer</a>
  
    <li><a href="../Attendee/Dehyphenizer.html">Attendee::Dehyphenizer</a>
  
    <li><a href="../Attendee/Formatter.html">Attendee::Formatter</a>
  
    <li><a href="../Attendee/Helper.html">Attendee::Helper</a>
  
    <li><a href="../Attendee/Multiworder.html">Attendee::Multiworder</a>
  
    <li><a href="../Attendee/Noneword_filter.html">Attendee::Noneword_filter</a>
  
    <li><a href="../Attendee/Objectfilter.html">Attendee::Objectfilter</a>
  
    <li><a href="../Attendee/Sequencer.html">Attendee::Sequencer</a>
  
    <li><a href="../Attendee/Synonymer.html">Attendee::Synonymer</a>
  
    <li><a href="../Attendee/Textreader.html">Attendee::Textreader</a>
  
    <li><a href="../Attendee/Textreader/PDFFilter.html">Attendee::Textreader::PDFFilter</a>
  
    <li><a href="../Attendee/Textwriter.html">Attendee::Textwriter</a>
  
    <li><a href="../Attendee/Tokenizer.html">Attendee::Tokenizer</a>
  
    <li><a href="../Attendee/Variator.html">Attendee::Variator</a>
  
    <li><a href="../Attendee/Vector_filter.html">Attendee::Vector_filter</a>
  
    <li><a href="../Attendee/Wordsearcher.html">Attendee::Wordsearcher</a>
  
    <li><a href="../Diff.html">Diff</a>
  
    <li><a href="../Diff/LCS.html">Diff::LCS</a>
  
    <li><a href="../Diff/LCS/DefaultCallbacks.html">Diff::LCS::BalancedCallbacks</a>
  
    <li><a href="../Diff/LCS/Block.html">Diff::LCS::Block</a>
  
    <li><a href="../Diff/LCS/Change.html">Diff::LCS::Change</a>
  
    <li><a href="../Diff/LCS/ChangeTypeTests.html">Diff::LCS::ChangeTypeTests</a>
  
    <li><a href="../Diff/LCS/ContextChange.html">Diff::LCS::ContextChange</a>
  
    <li><a href="../Diff/LCS/ContextDiffCallbacks.html">Diff::LCS::ContextDiffCallbacks</a>
  
    <li><a href="../Diff/LCS/DefaultCallbacks.html">Diff::LCS::DefaultCallbacks</a>
  
    <li><a href="../Diff/LCS/DiffCallbacks.html">Diff::LCS::DiffCallbacks</a>
  
    <li><a href="../Diff/LCS/Hunk.html">Diff::LCS::Hunk</a>
  
    <li><a href="../Diff/LCS/Ldiff.html">Diff::LCS::Ldiff</a>
  
    <li><a href="../Diff/LCS/SDiffCallbacks.html">Diff::LCS::SDiffCallbacks</a>
  
    <li><a href="../Diff/LCS/DefaultCallbacks.html">Diff::LCS::SequenceCallbacks</a>
  
    <li><a href="../Lingo.html">Lingo</a>
  
    <li><a href="../Lingo/Version.html">Lingo::Version</a>
  
    <li><a href="../AgendaItem.html">AgendaItem</a>
  
    <li><a href="../Array.html">Array</a>
  
    <li><a href="../BufferedAttendee.html">BufferedAttendee</a>
  
    <li><a href="../Cachable.html">Cachable</a>
  
    <li><a href="../Compositum.html">Compositum</a>
  
    <li><a href="../Crypter.html">Crypter</a>
  
    <li><a href="../DbmFile.html">DbmFile</a>
  
    <li><a href="../Dictionary.html">Dictionary</a>
  
    <li><a href="../File.html">File</a>
  
    <li><a href="../Grammar.html">Grammar</a>
  
    <li><a href="../IO.html">IO</a>
  
    <li><a href="../Lexical.html">Lexical</a>
  
    <li><a href="../LexicalHash.html">LexicalHash</a>
  
    <li><a href="../LingoConfig.html">LingoConfig</a>
  
    <li><a href="../Meeting.html">Meeting</a>
  
    <li><a href="../Object.html">Object</a>
  
    <li><a href="../Pathname.html">Pathname</a>
  
    <li><a href="../Reportable.html">Reportable</a>
  
    <li><a href="../ShowPercent.html">ShowPercent</a>
  
    <li><a href="../String.html">String</a>
  
    <li><a href="../StringA.html">StringA</a>
  
    <li><a href="../Token.html">Token</a>
  
    <li><a href="../Txt2DbmConverter.html">Txt2DbmConverter</a>
  
    <li><a href="../TxtFile.html">TxtFile</a>
  
    <li><a href="../TxtFile_Keyvalue.html">TxtFile_Keyvalue</a>
  
    <li><a href="../TxtFile_Multikey.html">TxtFile_Multikey</a>
  
    <li><a href="../TxtFile_Multivalue.html">TxtFile_Multivalue</a>
  
    <li><a href="../TxtFile_Singleword.html">TxtFile_Singleword</a>
  
    <li><a href="../TxtFile_Wordclass.html">TxtFile_Wordclass</a>
  
    <li><a href="../Word.html">Word</a>
  
    <li><a href="../WordSequence.html">WordSequence</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="module">module Diff::LCS</h1>

  <div id="description" class="description">
    
<h1 id="label-Diff%3A%3ALCS+1.1.2"><a href="LCS.html">Diff::LCS</a> 1.1.2</h1>

<p>Computes “intelligent” differences between two sequenced Enumerables. This
is an implementation of the McIlroy-Hunt “diff” algorithm for Enumerable
objects that include Diffable.</p>

<p>Based on Mario I. Wolczko’s &lt;mario@wolczko.com&gt; Smalltalk version
(1.2, 1993) and Ned Konz’s &lt;perl@bike-nomad.com&gt; Perl version
(Algorithm::Diff).</p>

<h2 id="label-Synopsis">Synopsis</h2>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'diff/lcs'</span>

<span class="ruby-identifier">seq1</span> = <span class="ruby-node">%w(a b c e h j l m n p)</span>
<span class="ruby-identifier">seq2</span> = <span class="ruby-node">%w(b c d e f j k l m r s t)</span>

<span class="ruby-identifier">lcs</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-constant">LCS</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)
<span class="ruby-identifier">diffs</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">diff</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)
<span class="ruby-identifier">sdiff</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">sdiff</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)
<span class="ruby-identifier">seq</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">traverse_sequences</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callback_obj</span>)
<span class="ruby-identifier">bal</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">traverse_balanced</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callback_obj</span>)
<span class="ruby-identifier">seq2</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">diffs</span>)
<span class="ruby-identifier">seq2</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch!</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">diffs</span>)
<span class="ruby-identifier">seq1</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">unpatch</span>(<span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">diffs</span>)
<span class="ruby-identifier">seq1</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">unpatch!</span>(<span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">diffs</span>)
<span class="ruby-identifier">seq2</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">sdiff</span>)
<span class="ruby-identifier">seq2</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch!</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">sdiff</span>)
<span class="ruby-identifier">seq1</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">unpatch</span>(<span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">sdiff</span>)
<span class="ruby-identifier">seq1</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">unpatch!</span>(<span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">sdiff</span>)
</pre>

<p>Alternatively, objects can be extended with Diff::LCS:</p>

<pre>seq1.extend(Diff::LCS)
lcs = seq1.lcs(seq2)
diffs = seq1.diff(seq2)
sdiff = seq1.sdiff(seq2)
seq = seq1.traverse_sequences(seq2, callback_obj)
bal = seq1.traverse_balanced(seq2, callback_obj)
seq2 == seq1.patch(diffs)
seq2 == seq1.patch!(diffs)
seq1 == seq2.unpatch(diffs)
seq1 == seq2.unpatch!(diffs)
seq2 == seq1.patch(sdiff)
seq2 == seq1.patch!(sdiff)
seq1 == seq2.unpatch(sdiff)
seq1 == seq2.unpatch!(sdiff)</pre>

<p>Default extensions are provided for <a href="../Array.html">Array</a> and
<a href="../String.html">String</a> objects through the use of
‘diff/lcs/array’ and ‘diff/lcs/string’.</p>

<h2 id="label-Introduction+%28by+Mark-Jason+Dominus%29">Introduction (by Mark-Jason Dominus)</h2>

<p><em>The following text is from the Perl documentation. The only changes
have been to make the text appear better in Rdoc</em>.</p>

<p>I once read an article written by the authors of <code>diff</code>; they
said that they hard worked very hard on the algorithm until they found the
right one.</p>

<p>I think what they ended up using (and I hope someone will correct me,
because I am not very confident about this) was the `longest common
subsequence’ method. In the <a href="LCS.html">LCS</a> problem, you have
two sequences of items:</p>

<pre>a b c d f g h j q z
a b c d e f g i j k r x y z</pre>

<p>and you want to find the longest sequence of items that is present in both
original sequences in the same order. That is, you want to find a new
sequence <strong>S</strong> which can be obtained from the first sequence
by deleting some items, and from the second sequence by deleting other
items. You also want <strong>S</strong> to be as long as possible. In this
case <strong>S</strong> is:</p>

<pre>a b c d f g j z</pre>

<p>From there it’s only a small step to get diff-like output:</p>

<pre>e   h i   k   q r x y
+   - +   +   - + + +</pre>

<p>This module solves the <a href="LCS.html">LCS</a> problem. It also includes
a canned function to generate <code>diff</code>-like output.</p>

<p>It might seem from the example above that the <a href="LCS.html">LCS</a> of
two sequences is always pretty obvious, but that’s not always the case,
especially when the two sequences have many repeated elements. For example,
consider</p>

<pre>a x b y c z p d q
a b c a x b y c z</pre>

<p>A naive approach might start by matching up the <code>a</code> and
<code>b</code> that appear at the beginning of each sequence, like this:</p>

<pre>a x b y c         z p d q
a   b   c a b y c z</pre>

<p>This finds the common subsequence +a b c z+. But actually, the <a
href="LCS.html">LCS</a> is +a x b y c z+:</p>

<pre>      a x b y c z p d q
a b c a x b y c z</pre>

<h2 id="label-Author">Author</h2>

<p>This version is by Austin Ziegler &lt;diff-lcs@halostatue.ca&gt;.</p>

<p>It is based on the Perl Algorithm::Diff by Ned Konz
&lt;perl@bike-nomad.com&gt;, copyright &amp;copy; 2000 - 2002 and the
Smalltalk diff version by Mario I. Wolczko &lt;mario@wolczko.com&gt;,
copyright &amp;copy;</p>
<ol><li>
<p>Documentation includes work by Mark-Jason Dominus.</p>
</li></ol>

<h2 id="label-Licence">Licence</h2>

<p>Copyright &amp;copy; 2004 Austin Ziegler This program is free software; you
can redistribute it and/or modify it under the same terms as Ruby, or
alternatively under the Perl Artistic licence.</p>

<h2 id="label-Credits">Credits</h2>

<p>Much of the documentation is taken directly from the Perl Algorithm::Diff
implementation and was written originally by Mark-Jason Dominus
&lt;mjd-perl-diff@plover.com&gt; and later by Ned Konz. The basic Ruby
implementation was re-ported from the Smalltalk implementation, available
at <a
href="ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st">st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st</a></p>

<p><a href="LCS.html#method-i-sdiff">#sdiff</a> and <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a> were
written for the Perl version by Mike Schilli &lt;m@perlmeister.com&gt;.</p>

<p>“The algorithm is described in <em>A Fast Algorithm for Computing Longest
Common Subsequences</em>, CACM, vol.20, no.5, pp.350-353, May 1977, with a
few minor improvements to improve the speed.”</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="BalancedCallbacks">BalancedCallbacks
        
        <dd class="description"><p>An alias for <a href="LCS/DefaultCallbacks.html">DefaultCallbacks</a> that
is used in <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a>.</p>

<pre>Diff::LCS.LCS(seq1, seq2, Diff::LCS::BalancedCallbacks)</pre>
        
      
        <dt id="PATCH_MAP">PATCH_MAP
        
        <dd class="description">
        
      
        <dt id="SequenceCallbacks">SequenceCallbacks
        
        <dd class="description"><p>An alias for <a href="LCS/DefaultCallbacks.html">DefaultCallbacks</a> that
is used in <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>.</p>

<pre>Diff::LCS.LCS(seq1, seq2, Diff::LCS::SequenceCallbacks)</pre>
        
      
        <dt id="VERSION">VERSION
        
        <dd class="description">
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-LCS" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">LCS</span><span
            class="method-args">(seq1, seq2) { |seq1)| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given two sequenced Enumerables, <a href="LCS.html">LCS</a> returns an <a
href="../Array.html">Array</a> containing their longest common
subsequences.</p>

<pre>lcs = Diff::LCS.LCS(seq1, seq2)</pre>

<p>This array whose contents is such that:</p>

<pre class="ruby"><span class="ruby-identifier">lcs</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ee</span>, <span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">assert</span>(<span class="ruby-identifier">ee</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ii</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">ee</span>]))
<span class="ruby-keyword">end</span>
</pre>

<p>If a block is provided, the matching subsequences will be yielded from
<code>seq1</code> in turn and may be modified before they are placed into
the returned <a href="../Array.html">Array</a> of subsequences.</p>
          

          
          <div class="method-source-code" id="LCS-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">LCS</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment">#:yields seq1[ii] for each matched:</span>
  <span class="ruby-identifier">matches</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__lcs</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)
  <span class="ruby-identifier">ret</span> = []
  <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ee</span>, <span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">matches</span>[<span class="ruby-identifier">ii</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">ret</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ii</span>])
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">ret</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ii</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ret</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- LCS-source -->
          
        </div>

        

        
      </div><!-- LCS-method -->

    
      <div id="method-c-__diff_direction" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__diff_direction</span><span
            class="method-args">(src, patchset, limit = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Examine the patchset and the source to see in which direction the patch
should be applied.</p>

<p>WARNING: By default, this examines the whole patch, so this could take some
time. This also works better with <a
href="LCS/ContextChange.html">Diff::LCS::ContextChange</a> or <a
href="LCS/Change.html">Diff::LCS::Change</a> as its source, as an array
will cause the creation of one of the above.</p>
          

          
          <div class="method-source-code" id="__diff_direction-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 939</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__diff_direction</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>, <span class="ruby-identifier">limit</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">count</span> = <span class="ruby-identifier">left</span> = <span class="ruby-identifier">left_miss</span> = <span class="ruby-identifier">right</span> = <span class="ruby-identifier">right_miss</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">string</span> = <span class="ruby-identifier">src</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>)

  <span class="ruby-identifier">patchset</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">change</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

    <span class="ruby-keyword">case</span> <span class="ruby-identifier">change</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">Change</span>
        <span class="ruby-comment"># With a simplistic change, we can't tell the difference between</span>
        <span class="ruby-comment"># the left and right on '!' actions, so we ignore those. On '='</span>
        <span class="ruby-comment"># actions, if there's a miss, we miss both left and right.</span>
      <span class="ruby-identifier">element</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">position</span>]

      <span class="ruby-keyword">case</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">action</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'-'</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">element</span>
          <span class="ruby-identifier">left</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">left_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'+'</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">element</span>
          <span class="ruby-identifier">right</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">right_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'='</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">element</span>
          <span class="ruby-identifier">left_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">right_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">action</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'-'</span> <span class="ruby-comment"># Remove details from the old string</span>
        <span class="ruby-identifier">element</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_element</span>
          <span class="ruby-identifier">left</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">left_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'+'</span>
        <span class="ruby-identifier">element</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_element</span>
          <span class="ruby-identifier">right</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">right_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'='</span>
        <span class="ruby-identifier">le</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>]
        <span class="ruby-identifier">re</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>]

        <span class="ruby-identifier">left_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">le</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_element</span>
        <span class="ruby-identifier">right_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">re</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_element</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'!'</span>
        <span class="ruby-identifier">element</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_element</span>
          <span class="ruby-identifier">left</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">element</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>]
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_element</span>
            <span class="ruby-identifier">right</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">left_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
            <span class="ruby-identifier">right_miss</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">limit</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">count</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">limit</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">no_left</span> = (<span class="ruby-identifier">left</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>) <span class="ruby-keyword">and</span> (<span class="ruby-identifier">left_miss</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>)
  <span class="ruby-identifier">no_right</span> = (<span class="ruby-identifier">right</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>) <span class="ruby-keyword">and</span> (<span class="ruby-identifier">right_miss</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>)

  <span class="ruby-keyword">case</span> [<span class="ruby-identifier">no_left</span>, <span class="ruby-identifier">no_right</span>]
  <span class="ruby-keyword">when</span> [<span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>]
    <span class="ruby-keyword">return</span> <span class="ruby-value">:patch</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>]
    <span class="ruby-keyword">return</span> <span class="ruby-value">:unpatch</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;The provided patchset does not appear to apply to the provided value as either source or destination value.&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __diff_direction-source -->
          
        </div>

        

        
      </div><!-- __diff_direction-method -->

    
      <div id="method-c-__inverse_vector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__inverse_vector</span><span
            class="method-args">(a, vector)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>If <code>vector</code> maps the matching elements of another collection
onto this Enumerable, compute the inverse <code>vector</code> that maps
this Enumerable onto the collection. (Currently unused.)</p>
          

          
          <div class="method-source-code" id="__inverse_vector-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 912</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__inverse_vector</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">vector</span>)
  <span class="ruby-identifier">inverse</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>
  (<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-identifier">vector</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">inverse</span>[<span class="ruby-identifier">vector</span>[<span class="ruby-identifier">ii</span>]] = <span class="ruby-identifier">ii</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector</span>[<span class="ruby-identifier">ii</span>].<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">inverse</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __inverse_vector-source -->
          
        </div>

        

        
      </div><!-- __inverse_vector-method -->

    
      <div id="method-c-__lcs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__lcs</span><span
            class="method-args">(a, b)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>private Compute the longest common subsequence between the sequenced
Enumerables <code>a</code> and <code>b</code>. The result is an array whose
contents is such that</p>

<pre class="ruby"><span class="ruby-identifier">result</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__lcs</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)
<span class="ruby-identifier">result</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">assert_equal</span>(<span class="ruby-identifier">a</span>[<span class="ruby-identifier">ii</span>], <span class="ruby-identifier">b</span>[<span class="ruby-identifier">e</span>]) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">nil?</span>
<span class="ruby-keyword">end</span>
</pre>
          

          
          <div class="method-source-code" id="__lcs-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 816</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__lcs</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)
  <span class="ruby-identifier">a_start</span> = <span class="ruby-identifier">b_start</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">a_finish</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">b_finish</span> = <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">vector</span> = []

    <span class="ruby-comment"># Prune off any common elements at the beginning...</span>
  <span class="ruby-keyword">while</span> (<span class="ruby-identifier">a_start</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">a_finish</span>) <span class="ruby-keyword">and</span>
        (<span class="ruby-identifier">b_start</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">b_finish</span>) <span class="ruby-keyword">and</span>
        (<span class="ruby-identifier">a</span>[<span class="ruby-identifier">a_start</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>[<span class="ruby-identifier">b_start</span>])
    <span class="ruby-identifier">vector</span>[<span class="ruby-identifier">a_start</span>] = <span class="ruby-identifier">b_start</span>
    <span class="ruby-identifier">a_start</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">b_start</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Now the end...</span>
  <span class="ruby-keyword">while</span> (<span class="ruby-identifier">a_start</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">a_finish</span>) <span class="ruby-keyword">and</span>
        (<span class="ruby-identifier">b_start</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">b_finish</span>) <span class="ruby-keyword">and</span>
        (<span class="ruby-identifier">a</span>[<span class="ruby-identifier">a_finish</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>[<span class="ruby-identifier">b_finish</span>])
    <span class="ruby-identifier">vector</span>[<span class="ruby-identifier">a_finish</span>] = <span class="ruby-identifier">b_finish</span>
    <span class="ruby-identifier">a_finish</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">b_finish</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Now, compute the equivalence classes of positions of elements.</span>
  <span class="ruby-identifier">b_matches</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__position_hash</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">b_start</span> <span class="ruby-operator">..</span> <span class="ruby-identifier">b_finish</span>)

  <span class="ruby-identifier">thresh</span> = []
  <span class="ruby-identifier">links</span> = []

  (<span class="ruby-identifier">a_start</span> <span class="ruby-operator">..</span> <span class="ruby-identifier">a_finish</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">a</span>[<span class="ruby-identifier">ii</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">a</span>[<span class="ruby-identifier">ii</span>]
    <span class="ruby-identifier">bm</span> = <span class="ruby-identifier">b_matches</span>[<span class="ruby-identifier">ai</span>]
    <span class="ruby-identifier">kk</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">bm</span>.<span class="ruby-identifier">reverse_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">jj</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">kk</span> <span class="ruby-keyword">and</span> (<span class="ruby-identifier">thresh</span>[<span class="ruby-identifier">kk</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">jj</span>) <span class="ruby-keyword">and</span> (<span class="ruby-identifier">thresh</span>[<span class="ruby-identifier">kk</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">jj</span>)
        <span class="ruby-identifier">thresh</span>[<span class="ruby-identifier">kk</span>] = <span class="ruby-identifier">jj</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">kk</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__replace_next_larger</span>(<span class="ruby-identifier">thresh</span>, <span class="ruby-identifier">jj</span>, <span class="ruby-identifier">kk</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">links</span>[<span class="ruby-identifier">kk</span>] = [ (<span class="ruby-identifier">kk</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">links</span>[<span class="ruby-identifier">kk</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">ii</span>, <span class="ruby-identifier">jj</span> ] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">kk</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">thresh</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">link</span> = <span class="ruby-identifier">links</span>[<span class="ruby-identifier">thresh</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>]
    <span class="ruby-keyword">while</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">link</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">vector</span>[<span class="ruby-identifier">link</span>[<span class="ruby-value">1</span>]] = <span class="ruby-identifier">link</span>[<span class="ruby-value">2</span>]
      <span class="ruby-identifier">link</span> = <span class="ruby-identifier">link</span>[<span class="ruby-value">0</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">vector</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __lcs-source -->
          
        </div>

        

        
      </div><!-- __lcs-method -->

    
      <div id="method-c-__normalize_patchset" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__normalize_patchset</span><span
            class="method-args">(patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Normalize the patchset. A patchset is always a sequence of changes, but how
those changes are represented may vary, depending on how they were
generated. In all cases we support, we also support the array
representation of the changes. The formats are:</p>

<pre>[ # patchset &lt;- Diff::LCS.diff(a, b)
  [ # one or more hunks
    Diff::LCS::Change # one or more changes
  ] ]

[ # patchset, equivalent to the above
  [ # one or more hunks
    [ action, line, value ] # one or more changes
  ] ]

[ # patchset &lt;- Diff::LCS.diff(a, b, Diff::LCS::ContextDiffCallbacks)
  #       OR &lt;- Diff::LCS.sdiff(a, b, Diff::LCS::ContextDiffCallbacks)
  [ # one or more hunks
    Diff::LCS::ContextChange # one or more changes
  ] ]

[ # patchset, equivalent to the above
  [ # one or more hunks
    [ action, [ old line, old value ], [ new line, new value ] ]
      # one or more changes
  ] ]

[ # patchset &lt;- Diff::LCS.sdiff(a, b)
  #       OR &lt;- Diff::LCS.diff(a, b, Diff::LCS::SDiffCallbacks)
  Diff::LCS::ContextChange # one or more changes
]

[ # patchset, equivalent to the above
  [ action, [ old line, old value ], [ new line, new value ] ]
    # one or more changes
]</pre>

<p>The result of this will be either of the following.</p>

<pre>[ # patchset
  Diff::LCS::ContextChange # one or more changes
]

[ # patchset
  Diff::LCS::Change # one or more changes
]</pre>

<p>If either of the above is provided, it will be returned as such.</p>
          

          
          <div class="method-source-code" id="__normalize_patchset-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 1075</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__normalize_patchset</span>(<span class="ruby-identifier">patchset</span>)
  <span class="ruby-identifier">patchset</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">hunk</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">hunk</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>, <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">Change</span>
      <span class="ruby-identifier">hunk</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>
      <span class="ruby-keyword">if</span> (<span class="ruby-keyword">not</span> <span class="ruby-identifier">hunk</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)) <span class="ruby-keyword">and</span> <span class="ruby-identifier">hunk</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">hunk</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">from_a</span>(<span class="ruby-identifier">hunk</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">hunk</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">change</span><span class="ruby-operator">|</span>
          <span class="ruby-keyword">case</span> <span class="ruby-identifier">change</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>, <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">Change</span>
            <span class="ruby-identifier">change</span>
          <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>
              <span class="ruby-comment"># change[1] will ONLY be an array in a ContextChange#to_a call.</span>
              <span class="ruby-comment"># In Change#to_a, it represents the line (singular).</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">change</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
              <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">from_a</span>(<span class="ruby-identifier">change</span>)
            <span class="ruby-keyword">else</span>
              <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">Change</span>.<span class="ruby-identifier">from_a</span>(<span class="ruby-identifier">change</span>)
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;Cannot normalise a hunk of class #{hunk.class}.&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">flatten</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __normalize_patchset-source -->
          
        </div>

        

        
      </div><!-- __normalize_patchset-method -->

    
      <div id="method-c-__position_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__position_hash</span><span
            class="method-args">(enum, interval = 0 .. -1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns a hash mapping each element of an Enumerable to the set of
positions it occupies in the Enumerable, optionally restricted to the
elements specified in the range of indexes specified by
<code>interval</code>.</p>
          

          
          <div class="method-source-code" id="__position_hash-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 923</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__position_hash</span>(<span class="ruby-identifier">enum</span>, <span class="ruby-identifier">interval</span> = <span class="ruby-value">0</span> <span class="ruby-operator">..</span> <span class="ruby-value">-1</span>)
  <span class="ruby-identifier">hash</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hh</span>, <span class="ruby-identifier">kk</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hh</span>[<span class="ruby-identifier">kk</span>] = [] }
  <span class="ruby-identifier">interval</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">kk</span> = <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">ii</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">ii</span>]
    <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">kk</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ii</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">hash</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __position_hash-source -->
          
        </div>

        

        
      </div><!-- __position_hash-method -->

    
      <div id="method-c-__replace_next_larger" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__replace_next_larger</span><span
            class="method-args">(enum, value, last_index = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Find the place at which <code>value</code> would normally be inserted into
the Enumerable. If that place is already occupied by <code>value</code>, do
nothing and return <code>nil</code>. If the place does not exist (i.e., it
is off the end of the Enumerable), add it to the end. Otherwise, replace
the element at that point with <code>value</code>. It is assumed that the
Enumerable’s values are numeric.</p>

<p>This operation preserves the sort order.</p>
          

          
          <div class="method-source-code" id="__replace_next_larger-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 879</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__replace_next_larger</span>(<span class="ruby-identifier">enum</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">last_index</span> = <span class="ruby-keyword">nil</span>)
    <span class="ruby-comment"># Off the end?</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span> (<span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">enum</span>[<span class="ruby-value">-1</span>])
    <span class="ruby-identifier">enum</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">value</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Binary search for the insertion point</span>
  <span class="ruby-identifier">last_index</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">first_index</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">while</span> (<span class="ruby-identifier">first_index</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">last_index</span>)
    <span class="ruby-identifier">ii</span> = (<span class="ruby-identifier">first_index</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">last_index</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span>

    <span class="ruby-identifier">found</span> = <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">ii</span>]

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">found</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">found</span>
      <span class="ruby-identifier">first_index</span> = <span class="ruby-identifier">ii</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">last_index</span> = <span class="ruby-identifier">ii</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># The insertion point is in first_index; overwrite the next larger</span>
    <span class="ruby-comment"># value.</span>
  <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">first_index</span>] = <span class="ruby-identifier">value</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">first_index</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- __replace_next_larger-source -->
          
        </div>

        

        
      </div><!-- __replace_next_larger-method -->

    
      <div id="method-c-diff" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">diff</span><span
            class="method-args">(seq1, seq2, callbacks = nil) { |block| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="LCS.html#method-i-diff">#diff</a> computes the smallest set of
additions and deletions necessary to turn the first sequence into the
second, and returns a description of these changes.</p>

<p>See <a href="LCS/DiffCallbacks.html">Diff::LCS::DiffCallbacks</a> for the
default behaviour. An alternate behaviour may be implemented with <a
href="LCS/ContextDiffCallbacks.html">Diff::LCS::ContextDiffCallbacks</a>.
If a Class argument is provided for <code>callbacks</code>, <a
href="LCS.html#method-i-diff">#diff</a> will attempt to initialise it. If
the <code>callbacks</code> object (possibly initialised) responds to
finish, it will be called.</p>
          

          
          <div class="method-source-code" id="diff-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diff</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yields diff changes:</span>
  <span class="ruby-identifier">callbacks</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">DiffCallbacks</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Class</span>)
    <span class="ruby-identifier">cb</span> = <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">rescue</span> <span class="ruby-identifier">callbacks</span>
    <span class="ruby-identifier">callbacks</span> = <span class="ruby-identifier">cb</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">traverse_sequences</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span>)
  <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">finish</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:finish</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">diffs</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">hunk</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">hunk</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">hunk</span> = <span class="ruby-identifier">hunk</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">block</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">block</span> }
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">yield</span> <span class="ruby-identifier">hunk</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">res</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">diffs</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- diff-source -->
          
        </div>

        

        
      </div><!-- diff-method -->

    
      <div id="method-c-patch" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">patch</span><span
            class="method-args">(src, patchset, direction = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given a patchset, convert the current version to the new version. If
<code>direction</code> is not specified (must be <code>:patch</code> or
<code>:unpatch</code>), then discovery of the direction of the patch will
be attempted.</p>
          

          
          <div class="method-source-code" id="patch-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 697</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">patch</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>, <span class="ruby-identifier">direction</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">string</span> = <span class="ruby-identifier">src</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>)
    <span class="ruby-comment"># Start with a new empty type of the source's class</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-identifier">src</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">new</span>

    <span class="ruby-comment"># Normalize the patchset.</span>
  <span class="ruby-identifier">patchset</span> = <span class="ruby-identifier">__normalize_patchset</span>(<span class="ruby-identifier">patchset</span>)

  <span class="ruby-identifier">direction</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__diff_direction</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>)
  <span class="ruby-identifier">direction</span> <span class="ruby-operator">||=</span> <span class="ruby-value">:patch</span>

  <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">bj</span> = <span class="ruby-value">0</span>

  <span class="ruby-identifier">patchset</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">change</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># Both Change and ContextChange support #action</span>
    <span class="ruby-identifier">action</span> = <span class="ruby-constant">PATCH_MAP</span>[<span class="ruby-identifier">direction</span>][<span class="ruby-identifier">change</span>.<span class="ruby-identifier">action</span>]

    <span class="ruby-keyword">case</span> <span class="ruby-identifier">change</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">direction</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:patch</span>
        <span class="ruby-identifier">el</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_element</span>
        <span class="ruby-identifier">op</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>
        <span class="ruby-identifier">np</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:unpatch</span>
        <span class="ruby-identifier">el</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_element</span>
        <span class="ruby-identifier">op</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">new_position</span>
        <span class="ruby-identifier">np</span> = <span class="ruby-identifier">change</span>.<span class="ruby-identifier">old_position</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">case</span> <span class="ruby-identifier">action</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'-'</span> <span class="ruby-comment"># Remove details from the old string</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">op</span>
          <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'+'</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">np</span>
          <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">el</span>
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'='</span>
          <span class="ruby-comment"># This only appears in sdiff output with the SDiff callback.</span>
          <span class="ruby-comment"># Therefore, we only need to worry about dealing with a single</span>
          <span class="ruby-comment"># element.</span>
        <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">el</span>

        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'!'</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">op</span>
          <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

        <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">el</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">Change</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">action</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'-'</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">position</span>
          <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">when</span> <span class="ruby-string">'+'</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">position</span>
          <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

        <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">change</span>.<span class="ruby-identifier">element</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">src</span>.<span class="ruby-identifier">size</span>
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">src</span>[<span class="ruby-identifier">ai</span>])
    <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- patch-source -->
          
        </div>

        

        
      </div><!-- patch-method -->

    
      <div id="method-c-patch-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">patch!</span><span
            class="method-args">(src, patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given a set of patchset, convert the current version to the next version.
Does no auto-discovery.</p>
          

          
          <div class="method-source-code" id="patch-21-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 804</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">patch!</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>, <span class="ruby-value">:patch</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- patch-21-source -->
          
        </div>

        

        
      </div><!-- patch-21-method -->

    
      <div id="method-c-sdiff" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sdiff</span><span
            class="method-args">(seq1, seq2, callbacks = nil) { |block| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="LCS.html#method-i-sdiff">#sdiff</a> computes all necessary
components to show two sequences and their minimized differences side by
side, just like the Unix utility <em>sdiff</em> does:</p>

<pre>old        &lt;     -
same             same
before     |     after
-          &gt;     new</pre>

<p>See <a href="LCS/SDiffCallbacks.html">Diff::LCS::SDiffCallbacks</a> for the
default behaviour. An alternate behaviour may be implemented with <a
href="LCS/ContextDiffCallbacks.html">Diff::LCS::ContextDiffCallbacks</a>.
If a Class argument is provided for <code>callbacks</code>, <a
href="LCS.html#method-i-diff">#diff</a> will attempt to initialise it. If
the <code>callbacks</code> object (possibly initialised) responds to
finish, it will be called.</p>
          

          
          <div class="method-source-code" id="sdiff-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 291</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sdiff</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment">#:yields diff changes:</span>
  <span class="ruby-identifier">callbacks</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">SDiffCallbacks</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Class</span>)
    <span class="ruby-identifier">cb</span> = <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">rescue</span> <span class="ruby-identifier">callbacks</span>
    <span class="ruby-identifier">callbacks</span> = <span class="ruby-identifier">cb</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">traverse_balanced</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span>)
  <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">finish</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:finish</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">diffs</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">hunk</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">hunk</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>)
        <span class="ruby-identifier">hunk</span> = <span class="ruby-identifier">hunk</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">block</span><span class="ruby-operator">|</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">block</span> }
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">yield</span> <span class="ruby-identifier">hunk</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">res</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">diffs</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- sdiff-source -->
          
        </div>

        

        
      </div><!-- sdiff-method -->

    
      <div id="method-c-traverse_balanced" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">traverse_balanced</span><span
            class="method-args">(seq1, seq2, callbacks = Diff::LCS::BalancedCallbacks) { |event| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a> is an
alternative to <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>. It
uses a different algorithm to iterate through the entries in the computed
longest common subsequence. Instead of viewing the changes as insertions or
deletions from one of the sequences, <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a> will
report <em>changes</em> between the sequences. To represent a</p>

<p>The arguments to <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a> are the
two sequences to traverse and a callback object, like this:</p>

<pre>traverse_balanced(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)</pre>

<p><a href="LCS.html#method-i-sdiff">#sdiff</a> is implemented with <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a>.</p>

<h2 id="method-c-traverse_balanced-label-Callback+Methods">Callback Methods</h2>

<p>Optional callback methods are <em>emphasized</em>.</p>
<dl class="rdoc-list note-list"><dt>callbacksmatch
<dd>
<p>Called when <code>a</code> and <code>b</code> are pointing to common
elements in <code>A</code> and <code>B</code>.</p>
</dd><dt>callbacksdiscard_a
<dd>
<p>Called when <code>a</code> is pointing to an element not in <code>B</code>.</p>
</dd><dt>callbacksdiscard_b
<dd>
<p>Called when <code>b</code> is pointing to an element not in <code>A</code>.</p>
</dd><dt><em>callbackschange</em>
<dd>
<p>Called when <code>a</code> and <code>b</code> are pointing to the same
relative position, but <code>A[a]</code> and <code>B[b]</code> are not the
same; a <em>change</em> has occurred.</p>
</dd></dl>

<p><a href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a> might
be a bit slower than <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>,
noticable only while processing huge amounts of data.</p>

<p>The <code>sdiff</code> function of this module is implemented as call to <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a>.</p>

<h2 id="method-c-traverse_balanced-label-Algorithm">Algorithm</h2>

<pre>a---+
    v
A = a b c e h j l m n p
B = b c d e f j k l m r s t
    ^
b---+</pre>

<h3 id="method-c-traverse_balanced-label-Matches">Matches</h3>

<p>If there are two arrows (<code>a</code> and <code>b</code>) pointing to
elements of sequences <code>A</code> and <code>B</code>, the arrows will
initially point to the first elements of their respective sequences. <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
advance the arrows through the sequences one element at a time, calling a
method on the user-specified callback object before each advance. It will
advance the arrows in such a way that if there are elements
<code>A[ii]</code> and <code>B[jj]</code> which are both equal and part of
the longest common subsequence, there will be some moment during the
execution of <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> when
arrow <code>a</code> is pointing to <code>A[ii]</code> and arrow
<code>b</code> is pointing to <code>B[jj]</code>. When this happens, <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
call <code>callbacks#match</code> and then it will advance both arrows.</p>

<h3 id="method-c-traverse_balanced-label-Discards">Discards</h3>

<p>Otherwise, one of the arrows is pointing to an element of its sequence that
is not part of the longest common subsequence. <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
advance that arrow and will call <code>callbacks#discard_a</code> or
<code>callbacks#discard_b</code>, depending on which arrow it advanced.</p>

<h3 id="method-c-traverse_balanced-label-Changes">Changes</h3>

<p>If both <code>a</code> and <code>b</code> point to elements that are not
part of the longest common subsequence, then <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
try to call <code>callbacks#change</code> and advance both arrows. If
<code>callbacks#change</code> is not implemented, then
<code>callbacks#discard_a</code> and <code>callbacks#discard_b</code> will
be called in turn.</p>

<p>The methods for <code>callbacks#match</code>,
<code>callbacks#discard_a</code>, <code>callbacks#discard_b</code>, and
<code>callbacks#change</code> are invoked with an event comprising the
action (“=”, “+”, “-”, or “!”, respectively), the indicies <code>ii</code>
and <code>jj</code>, and the elements <code>A[ii]</code> and
<code>B[jj]</code>. Return values are discarded by <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a>.</p>

<h3 id="method-c-traverse_balanced-label-Context">Context</h3>

<p>Note that <code>ii</code> and <code>jj</code> may not be the same index
position, even if <code>a</code> and <code>b</code> are considered to be
pointing to matching or changed elements.</p>
          

          
          <div class="method-source-code" id="traverse_balanced-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 585</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">traverse_balanced</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">BalancedCallbacks</span>)
  <span class="ruby-identifier">matches</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__lcs</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)
  <span class="ruby-identifier">a_size</span> = <span class="ruby-identifier">seq1</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">b_size</span> = <span class="ruby-identifier">seq2</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">bj</span> = <span class="ruby-identifier">mb</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">ma</span> = <span class="ruby-value">-1</span>
  <span class="ruby-identifier">string</span> = <span class="ruby-identifier">seq1</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>)

    <span class="ruby-comment"># Process all the lines in the match vector.</span>
  <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-comment"># Find next match indices +ma+ and +mb+</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">ma</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ma</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">size</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">matches</span>[<span class="ruby-identifier">ma</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">ma</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># end of matches?</span>
    <span class="ruby-identifier">mb</span> = <span class="ruby-identifier">matches</span>[<span class="ruby-identifier">ma</span>]

      <span class="ruby-comment"># Change(seq2)</span>
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">ma</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">mb</span>)
      <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
      <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]

      <span class="ruby-keyword">case</span> [(<span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">ma</span>), (<span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">mb</span>)]
      <span class="ruby-keyword">when</span> [<span class="ruby-keyword">true</span>, <span class="ruby-keyword">true</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:change</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'!'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">change</span>(<span class="ruby-identifier">event</span>)
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
          <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">when</span> [<span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">when</span> [<span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># Match</span>
    <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
    <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
    <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'='</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
    <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">event</span>)
    <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">while</span> (<span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">a_size</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>)
    <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
    <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]

    <span class="ruby-keyword">case</span> [(<span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">a_size</span>), (<span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>)]
    <span class="ruby-keyword">when</span> [<span class="ruby-keyword">true</span>, <span class="ruby-keyword">true</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:change</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'!'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">change</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> [<span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span>]
      <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
      <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">when</span> [<span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>]
      <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
      <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- traverse_balanced-source -->
          
        </div>

        

        
      </div><!-- traverse_balanced-method -->

    
      <div id="method-c-traverse_sequences" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">traverse_sequences</span><span
            class="method-args">(seq1, seq2, callbacks = Diff::LCS::SequenceCallbacks) { |event| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><a href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> is
the most general facility provided by this module; <code>diff</code> and
<code>LCS</code> are implemented as calls to it.</p>

<p>The arguments to <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> are the
two sequences to traverse, and a callback object, like this:</p>

<pre>traverse_sequences(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)</pre>

<p><a href="LCS.html#method-i-diff">#diff</a> is implemented with <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>.</p>

<h2 id="method-c-traverse_sequences-label-Callback+Methods">Callback Methods</h2>

<p>Optional callback methods are <em>emphasized</em>.</p>
<dl class="rdoc-list note-list"><dt>callbacksmatch
<dd>
<p>Called when <code>a</code> and <code>b</code> are pointing to common
elements in <code>A</code> and <code>B</code>.</p>
</dd><dt>callbacksdiscard_a
<dd>
<p>Called when <code>a</code> is pointing to an element not in <code>B</code>.</p>
</dd><dt>callbacksdiscard_b
<dd>
<p>Called when <code>b</code> is pointing to an element not in <code>A</code>.</p>
</dd><dt><em>callbacksfinished_a</em>
<dd>
<p>Called when <code>a</code> has reached the end of sequence <code>A</code>.</p>
</dd><dt><em>callbacksfinished_b</em>
<dd>
<p>Called when <code>b</code> has reached the end of sequence <code>B</code>.</p>
</dd></dl>

<h2 id="method-c-traverse_sequences-label-Algorithm">Algorithm</h2>

<pre>a---+
    v
A = a b c e h j l m n p
B = b c d e f j k l m r s t
    ^
b---+</pre>

<p>If there are two arrows (<code>a</code> and <code>b</code>) pointing to
elements of sequences <code>A</code> and <code>B</code>, the arrows will
initially point to the first elements of their respective sequences. <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
advance the arrows through the sequences one element at a time, calling a
method on the user-specified callback object before each advance. It will
advance the arrows in such a way that if there are elements
<code>A[ii]</code> and <code>B[jj]</code> which are both equal and part of
the longest common subsequence, there will be some moment during the
execution of <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> when
arrow <code>a</code> is pointing to <code>A[ii]</code> and arrow
<code>b</code> is pointing to <code>B[jj]</code>. When this happens, <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
call <code>callbacks#match</code> and then it will advance both arrows.</p>

<p>Otherwise, one of the arrows is pointing to an element of its sequence that
is not part of the longest common subsequence. <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
advance that arrow and will call <code>callbacks#discard_a</code> or
<code>callbacks#discard_b</code>, depending on which arrow it advanced. If
both arrows point to elements that are not part of the longest common
subsequence, then <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a> will
advance one of them and call the appropriate callback, but it is not
specified which it will call.</p>

<p>The methods for <code>callbacks#match</code>,
<code>callbacks#discard_a</code>, and <code>callbacks#discard_b</code> are
invoked with an event comprising the action (“=”, “+”, or “-”,
respectively), the indicies <code>ii</code> and <code>jj</code>, and the
elements <code>A[ii]</code> and <code>B[jj]</code>. Return values are
discarded by <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>.</p>

<h3 id="method-c-traverse_sequences-label-End+of+Sequences">End of Sequences</h3>

<p>If arrow <code>a</code> reaches the end of its sequence before arrow
<code>b</code> does, traverse_sequence try to call
<code>callbacks#finished_a</code> with the last index and element of
<code>A</code> (<code>A[-1]</code>) and the current index and element of
<code>B</code> (<code>B[jj]</code>). If <code>callbacks#finished_a</code>
does not exist, then <code>callbacks#discard_b</code> will be called on
each element of <code>B</code> until the end of the sequence is reached
(the call will be done with <code>A[-1]</code> and <code>B[jj]</code> for
each element).</p>

<p>If <code>b</code> reaches the end of <code>B</code> before <code>a</code>
reaches the end of <code>A</code>, <code>callbacks#finished_b</code> will
be called with the current index and element of <code>A</code>
(<code>A[ii]</code>) and the last index and element of <code>B</code>
(<code>A[-1]</code>). Again, if <code>callbacks#finished_b</code> does not
exist on the callback object, then <code>callbacks#discard_a</code> will be
called on each element of <code>A</code> until the end of the sequence is
reached (<code>A[ii]</code> and <code>B[-1]</code>).</p>

<p>There is a chance that one additional <code>callbacks#discard_a</code> or
<code>callbacks#discard_b</code> will be called after the end of the
sequence is reached, if <code>a</code> has not yet reached the end of
<code>A</code> or <code>b</code> has not yet reached the end of
<code>B</code>.</p>
          

          
          <div class="method-source-code" id="traverse_sequences-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">traverse_sequences</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">SequenceCallbacks</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment">#:yields change events:</span>
  <span class="ruby-identifier">matches</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">__lcs</span>(<span class="ruby-identifier">seq1</span>, <span class="ruby-identifier">seq2</span>)

  <span class="ruby-identifier">run_finished_a</span> = <span class="ruby-identifier">run_finished_b</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">string</span> = <span class="ruby-identifier">seq1</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">String</span>)

  <span class="ruby-identifier">a_size</span> = <span class="ruby-identifier">seq1</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">b_size</span> = <span class="ruby-identifier">seq2</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">bj</span> = <span class="ruby-value">0</span>

  (<span class="ruby-value">0</span> <span class="ruby-operator">..</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ii</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">b_line</span> = <span class="ruby-identifier">matches</span>[<span class="ruby-identifier">ii</span>]

    <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ii</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ii</span>]
    <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">b_line</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ax</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ii</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_line</span>
        <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ii</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
      <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'='</span>, <span class="ruby-identifier">ii</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
      <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">ii</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

    <span class="ruby-comment"># The last entry (if any) processed was a match. +ai+ and +bj+ point</span>
    <span class="ruby-comment"># just past the last matching lines in their sequences.</span>
  <span class="ruby-keyword">while</span> (<span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">a_size</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>)
      <span class="ruby-comment"># last A?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a_size</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:finished_a</span>) <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">run_finished_a</span>
        <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-value">-1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-value">-1</span>]
        <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'&gt;'</span>, (<span class="ruby-identifier">a_size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">finished_a</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">run_finished_a</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
        <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
          <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
          <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
          <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># last B?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">b_size</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">a_size</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:finished_b</span>) <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">run_finished_b</span>
        <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
        <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-value">-1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-value">-1</span>]
        <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'&lt;'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, (<span class="ruby-identifier">b_size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">bx</span>)
        <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">finished_b</span>(<span class="ruby-identifier">event</span>)
        <span class="ruby-identifier">run_finished_b</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
        <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
          <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
          <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
          <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
          <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ai</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">a_size</span>
      <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
      <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
      <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'-'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
      <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_a</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-identifier">ai</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">bj</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">b_size</span>
      <span class="ruby-identifier">ax</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq1</span>[<span class="ruby-identifier">ai</span>]
      <span class="ruby-identifier">bx</span> = <span class="ruby-identifier">string</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">seq2</span>[<span class="ruby-identifier">bj</span>]
      <span class="ruby-identifier">event</span> = <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">ContextChange</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'+'</span>, <span class="ruby-identifier">ai</span>, <span class="ruby-identifier">ax</span>, <span class="ruby-identifier">bj</span>, <span class="ruby-identifier">bx</span>)
      <span class="ruby-identifier">event</span> = <span class="ruby-keyword">yield</span> <span class="ruby-identifier">event</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">callbacks</span>.<span class="ruby-identifier">discard_b</span>(<span class="ruby-identifier">event</span>)
      <span class="ruby-identifier">bj</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- traverse_sequences-source -->
          
        </div>

        

        
      </div><!-- traverse_sequences-method -->

    
      <div id="method-c-unpatch-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unpatch!</span><span
            class="method-args">(src, patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given a set of patchset, convert the current version to the prior version.
Does no auto-discovery.</p>
          

          
          <div class="method-source-code" id="unpatch-21-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 798</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unpatch!</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-identifier">patch</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">patchset</span>, <span class="ruby-value">:unpatch</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- unpatch-21-source -->
          
        </div>

        

        
      </div><!-- unpatch-21-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-diff" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">diff</span><span
            class="method-args">(other, callbacks = nil, &block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns the difference set between <code>self</code> and
<code>other</code>. See <a href="LCS.html#method-i-diff">#diff</a>.</p>
          

          
          <div class="method-source-code" id="diff-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diff</span>(<span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">diff</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- diff-source -->
          
        </div>

        

        
      </div><!-- diff-method -->

    
      <div id="method-i-lcs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">lcs</span><span
            class="method-args">(other, &block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns an <a href="../Array.html">Array</a> containing the longest common
subsequence(s) between <code>self</code> and <code>other</code>. See
Diff::LCS#<a href="LCS.html">LCS</a>.</p>

<pre>lcs = seq1.lcs(seq2)</pre>
          

          
          <div class="method-source-code" id="lcs-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lcs</span>(<span class="ruby-identifier">other</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment">#:yields self[ii] if there are matched subsequences:</span>
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span>.<span class="ruby-constant">LCS</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- lcs-source -->
          
        </div>

        

        
      </div><!-- lcs-method -->

    
      <div id="method-i-patch" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">patch</span><span
            class="method-args">(patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Attempts to patch a copy of <code>self</code> with the provided
<code>patchset</code>. See <a href="LCS.html#method-i-patch">#patch</a>.</p>
          

          
          <div class="method-source-code" id="patch-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">patch</span>(<span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">patch</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dup</span>, <span class="ruby-identifier">patchset</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- patch-source -->
          
        </div>

        

        
      </div><!-- patch-method -->

    
      <div id="method-i-patch-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">patch!</span><span
            class="method-args">(patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Attempts to patch <code>self</code> with the provided
<code>patchset</code>. See <a
href="LCS.html#method-i-patch-21">#patch!</a>. Does no autodiscovery.</p>
          

          
          <div class="method-source-code" id="patch-21-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">patch!</span>(<span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">patch!</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">patchset</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- patch-21-source -->
          
        </div>

        

        
      </div><!-- patch-21-method -->

    
      <div id="method-i-sdiff" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sdiff</span><span
            class="method-args">(other, callbacks = nil, &block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns the balanced (“side-by-side”) difference set between
<code>self</code> and <code>other</code>. See <a
href="LCS.html#method-i-sdiff">#sdiff</a>.</p>
          

          
          <div class="method-source-code" id="sdiff-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sdiff</span>(<span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">sdiff</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- sdiff-source -->
          
        </div>

        

        
      </div><!-- sdiff-method -->

    
      <div id="method-i-traverse_balanced" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">traverse_balanced</span><span
            class="method-args">(other, callbacks = nil, &block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Traverses the discovered longest common subsequences between
<code>self</code> and <code>other</code> using the alternate, balanced
algorithm. See <a
href="LCS.html#method-i-traverse_balanced">#traverse_balanced</a>.</p>
          

          
          <div class="method-source-code" id="traverse_balanced-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">traverse_balanced</span>(<span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">traverse_balanced</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> <span class="ruby-operator">||</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">YieldingCallbacks</span>,
                    &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- traverse_balanced-source -->
          
        </div>

        

        
      </div><!-- traverse_balanced-method -->

    
      <div id="method-i-traverse_sequences" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">traverse_sequences</span><span
            class="method-args">(other, callbacks = nil, &block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Traverses the discovered longest common subsequences between
<code>self</code> and <code>other</code>. See <a
href="LCS.html#method-i-traverse_sequences">#traverse_sequences</a>.</p>
          

          
          <div class="method-source-code" id="traverse_sequences-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">traverse_sequences</span>(<span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">traverse_sequences</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">other</span>, <span class="ruby-identifier">callbacks</span> <span class="ruby-operator">||</span> <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-constant">YieldingCallbacks</span>,
                     &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- traverse_sequences-source -->
          
        </div>

        

        
      </div><!-- traverse_sequences-method -->

    
      <div id="method-i-unpatch" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unpatch</span><span
            class="method-args">(patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Attempts to unpatch a copy of <code>self</code> with the provided
<code>patchset</code>. See <a href="LCS.html#method-i-patch">#patch</a>.</p>
          

          
          <div class="method-source-code" id="unpatch-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unpatch</span>(<span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">unpatch</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dup</span>, <span class="ruby-identifier">patchset</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- unpatch-source -->
          
        </div>

        

        
      </div><!-- unpatch-method -->

    
      <div id="method-i-unpatch-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">unpatch!</span><span
            class="method-args">(patchset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Attempts to unpatch <code>self</code> with the provided
<code>patchset</code>. See <a
href="LCS.html#method-i-unpatch">#unpatch</a>. Does no autodiscovery.</p>
          

          
          <div class="method-source-code" id="unpatch-21-source">
            <pre><span class="ruby-comment"># File lib/diff/lcs.rb, line 209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unpatch!</span>(<span class="ruby-identifier">patchset</span>)
  <span class="ruby-constant">Diff</span><span class="ruby-operator">::</span><span class="ruby-constant">LCS</span><span class="ruby-operator">::</span><span class="ruby-identifier">unpatch!</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">patchset</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- unpatch-21-source -->
          
        </div>

        

        
      </div><!-- unpatch-21-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.11.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

